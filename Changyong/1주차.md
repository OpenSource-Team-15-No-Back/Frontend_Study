# JavaScript 기초

## 변수

### 변수의 기초

```js
name = "Mike";
age = 30;
```

JavaScript에선 문자열을 따옴표롤 감싸줘야 한다.
이 때, 따옴표/겹따옵표 사용 가능하다.

예약어를 변수명으로 사용하는 경우 에러가 일어날 수 있다.

### 변수 접근해보기

```js
alert();
console.log();
```

JavaScript에서는 두 가지의 출력 방식이 있다.
`alert()`는 알림창을 통한 출력이고,
`console.log()`는 콘솔창을 통한 출력이라고 볼 수 있다.

### 변수의 위험

```js
name = "Mike";
age = 30;
```

위 방식은 저 위의 변수명이 유일하다는 보장이 없기에,
위와 같은 변수 선언은 매우 위험하다.

위의 위험을 막기 위한 키워드로 let과 const가 있다.

```js
let name = "Mike";
const AGE = 30;
```

let은 한 번 선언 후에 다른 값으로 바꿀 수 있다.

```js
let grade = "F";
grade = "A+";
```

const는 절대로 바뀌지 않는 상수를 선언한다.
이는 대문자로 사용하는 것이 좋다.

### 변수 선언 시 주의점

- 변수 선언 시 변수명은 문자와 숫자, $와 \_만 사용
- 변수명의 첫 글자는 숫자가 들어올 수 없음
- 변수명으로 예약어는 사용할 수 없음
- 가급적 상수는 대문자로 표시하는 것이 좋음
- 변수명은 읽기 쉽고 이해할 수 있게 선언

## 자료형

### String

```js
const name = "Changyong";
const name1 = "Changyong";
const name2 = `Changyong`;
// String은 위와 같이 세 가지 방식으로 문자열을 선언할 수 있음

console.log(`My name is ${name}`);
console.log(`My name is ${1 + 1}`);
console.log(`My name is ${name1 + name2}`);
//벡틱을 사용한 후 달러($)와 중괄호 사이에 변수나 표현식을 작성하면 알아서 변환됨
//문자열에 덧셈을 하면 문자열이 이어짐
```

```
//출력 결과
My name is Changyong
My name is 2
```

### Number

```js
const age = 20;
const PI = 3.14;

console.log(1 + 2);
console.log(10 - 1);
// Number는 사칙연산이 가능
```

```
//출력 결과
3
9
```

```js
console.log(1 / 0);

console.log("Changyong" / 2);
```

```
//출력 결과
Infinite
NaN
```

### Boolean

```js
const a = true;
const b = false;

const num1 = 5;
const num2 = 9;

console.log(num1 == num2);
console.log(nun1 < nun2);
```

```
//출력 결과
false
true
```

### null / undefined

null은 존재하지 않는 값을 나타낸다.
undefined는 값이 할당되지 않음을 나타낸다.

```js
let age;
let user = null;
console.log(age);
```

```
//출력 결과
undefined
```

### typeof 연산자

자료형의 type을 확인하는 데 사용한다.

```js
const name = "Changyong";

console.log(typeof name);
console.log(typeof 3);
console.log(typeof true);
console.log(typeof null);
console.log(typeof undefined);
```

```
//출력 결과
"number"
"string"
"boolean"
"object"
"undefined"
```

여기서 신기한 점은, null은 객체(object)가 아니라는 것이다.
JavaScript의 초기 버전에서의 오류인데,
호환성을 위해 오류를 수정하지 않는다고 한다.
